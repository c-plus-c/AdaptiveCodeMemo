# インタフェース分離の原則

* インタフェースをこまめにわけること
    * 巨大なインタフェースは不要なメソッドの実装を義務付けたり、クライアントに見えるものが多すぎるとシステムの仕様が複雑に見えてしまうなど良くない点が多い
    * デコレータで拡張しやすくするのにも必要
## interface Soupアンチパターン
* 分割されたインタフェースを何らかの理由で集約にまとめること
    * インタフェースの分離の利点が損なわれるのでよくない
# インタフェースの分割
## クライアントのニーズ
* クライアントに必要なものだけを与える
* 機能が多いinterfaceを渡すとユーザができることが多くなりすぎて、どうすればよいかわからなくなる
* 読み取り機能と書き込み機能を別のインタフェースにするとか
* 承認
    * アプリケーションが特定の状態にあるときだけ一連の操作が提供されるケース
    * クライアントのニーズに基づいてインタフェースを分割すると、プログラマーが本来実行すべきでないことを実行できなくなって良い
        * 非特権ユーザ向きの操作を提供するIUnAuthorized, 特権ユーザ向きの操作を提供するIAuthorizedインタフェースを用意するなど
        * この場合、特権を得ていない匿名ユーザが特権を必要とする操作をできなくすることができる
# アーキテクチャのニーズ
    * 同一のクラス内で、異なるアーキテクチャ（サードパーティのライブラリ等）を使う場合は、そのアーキテクチャが依存している単位で別々のインタフェースに分けたほうが良い
        * 例: CQSのクエリとコマンドは別々のクラスにするなど
            * コマンドの実装にNHibernate、クエリの実装にMongoDBを用いている場合
                * ICommand、IQueryに分割する
                * 欲を言うと、この二つの実装クラスは別々のアセンブリに保存したほうが良い
# シングルメソッドのインタフェース
* メソッドを一つしか持たないインタフェース
* シングルメソッドのインタフェースは、様々なデコレータで拡張できる