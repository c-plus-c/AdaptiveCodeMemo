# 依存関係と階層化
* レイヤー: コードの論理的な構成（ドメイン層、データアクセス層など）
* ティア: コードの物理的な構成（サーバマシンの数に多少関係する）

#### 二層アーキテクチャ
ユーザインタフェース層

↓

データアクセス層

* 漏れの抽象化
    * レイヤーの実装部分を上のレイヤーが直接参照すること
    * 上のレイヤーは下のレイヤーのあくまで抽象部分のみを参照すること

UI → データアクセスのインタフェース
　　　　↑
　　　データアクセスの実装

#### 三層アーキテクチャ
* アプリケーションに難しい処理が入る場合、その難しい処理はビジネスロジック層に含める

ユーザインタフェース層

↓

ビジネスロジック層

↓

データアクセス層

#### アスペクト指向プログラミング
* 横断的関心事（監査/セキュリティ/キャッシュ）を複数のレイヤーに適用する方法
    * 複数のレイヤーにまたがるコンポーネント
* メソッドに属性つけるのが代表的
    * Logged、Transactionalなど

### 非対称な階層化
サーバに送られたリクエストの流れは常に同じであるとは限らない：階層化が非対称
コマンド/クエリ債務分離（CQRS）: 最近注目の非対称の階層化パターン
#### CQS
* コマンド
    * アクションに対する命令的な呼び出しで、コードに何かを実行させる
    * 値を返してはいけない
    * メソッドが値を返してかつCQS純く尾ならそのメソッドはオブジェクトの状態を変更すると考えることができる
        * ゆえに呼び出しの順序に注意を払う必要がある

```cs
// CQS準拠のコマンドメソッド
public void SaveUser(string name)
{
    session.Save(new User(name));
}

// CQS非準拠のコマンドメソッド
public User SaveUser(string name){
    var user = new User(name);
    session.Save(user);
    return user;
}
```

* クエリ
    * データに対するリクエストであり、コードに何かを取得させる
    * システムの状態を変更しない

```cs
// CQS準拠のクエリメソッド
public IEnumerable<User> FindUserByID(Guid userID)
{
    return session.Get<User>(userID);
}

// CQS非準拠のクエリメソッド
public IEnumerable<User> FindUserByID(Guid userID)
{
    var user = session.Get<User>(userID);
    user.LastAccessed = DateTime.Now;
    return user;
}
```

* コマンドとクエリは戻り値の存在によって区別される

||メソッドが値を返す|メソッドが値を返さない|
|---|---|---|---|
|CQS準拠|メソッドはオブジェクトの状態を一切変更しない（クエリ呼び出しの順序を入れ替えることが可能）|そのメソッドはオブジェクトの状態を変更すると考えることができる（呼び出しの順序に気を付ける必要がある）|
|CQS非準拠|ノーコメント|ノーコメント|

#### CQRS
* CQSとほとんど同じルールだが、コマンドとクエリを最も効果的に処理するには、階層化を通じて異なるパスをたどるようにする必要があるかもしれないという認識に基づく。