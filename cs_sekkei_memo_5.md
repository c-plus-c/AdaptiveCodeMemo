# 単一債務の原則

* 単一債務の原則（SRP）は、変更する理由が一つしかないコードを記述するための原則
* クラスを変更する理由が一つではないとしたら、そのクラスには複数の債務が割り当てられている
    * 複数のより小さなクラスに分割すべき
    * 分割されたクラスがそれぞれお債務と変更する理由を一つだけ持つようにする
        * 主に委譲とか使う

# 債務が多すぎる例
* TradeProcessorクラスはファイルからレコードを読み取ってデータベースを更新するという処理を受け持つ
    * これをProcessTradesメソッドでいっぺんにやってしまっている
    * 抽象化が一切されていない
        * レコードの読み取りがStreamからWebサービスのリモート呼び出しが変わったらどうするのか
        * フォーマットが変わったとき、どうするのか
        * 検証ルールとか変更された時
        * ログ出力の方式が変更された時
    * 改善が大変
* ひとまずTradeProcessorクラス内でメソッドを分けるという考えの下改善してみる
    * データの読み取り・トレード情報のパース・データベース・検証への保存をTradeProcessor内の別々のメソッドに分ける
    * ただListをEnumerableに抽象化するなどのことはやっている
    * 読みやすくはなったが、適応性に関しては、ほどんど改善されていない
        * ログの出力方式を変えるだけでも、TradeProcessorをいじらなければいけない
* 抽象化のためのリファクタリング
    * プロトタイプと概念の実証は小さいアプリケーションのためにある用語
    * プロトタイプからプロダクションアプリケーションへの変換は比較的シームレス
    * スケーリングするプロジェクトなら間違いなく要る
    * 手順
        * まずTradeProcessorが持つ各々の債務を担当するオブジェクトのインタフェースを作る
            * ITradeDataProvider: トレードデータを取得する債務
            * ITradeParser: ITradeDataProviderが渡したデータをTradeProcessorで扱える形式にシリアライズする
            * ITradeStorage: トレード情報を永続化する
        * TradeProcessorはこれら3つのインタフェースに依存するようにする
            * Stairwayパターンに基づき、TradeProcessorが依存する全てのインタフェースは全てそれら専用の別のアセンブリ（SingleResponsibilityPrinciple.Contracts）に含まれる
            * さらにそれらの実装は別のアセンブリにまとめられている
            * これにより、各々の処理形式が変わってもTradeProcessorはそれを請け負う必要がない
            * ITradeDataProviderインタフェースはStreamクラスに依存しない
                * 各々の実装が依存する具象（サービスのSDKなど）はメソッドでなくコンストラクタで渡す
        * 更に、SimpleTradeParserクラスも分割する
            * マッピングと検証の債務を分割する
            * Parseする取引データの全体的な構造の変化に備えるため（CSVで読んでいたものがXMLになるなど）
        * ログ周りの抽象化
            * ログクラスを独自に実装するのではなく、Log4Netというログライブラリのためのアダプターを作成する
                * サードパーティの参照をファーストパーティの参照に変換できるようになるため
                * AdoNetTradeStorageやSimpleTradeValidatorはLogger昨日としてILoggerに依存している
                * Log4Netへの参照が必要なのは、アプリケーションのエントリポイントと、新たに作成されたService.Log4Netアセンブリのみ

# 単一債務の原則とDecoratorパターン
* 基本前提
    * 各デコレータクラスが型のコントラクト（契約）を満たすことと、それらの方をコンストラクタのパラメータとして受け取ること
* Compositeパターン
    * Decoratorパターンのより一般的な用途を表す特殊なDecoratorパターン
    * あるコンポーネントを複数個のコンポーネントでDecorateする
    * 述語デコレータ
        * ある特定の条件を満たすものしかdecorateに使わないよう指定するためのdecorator
    * 分岐デコレータ
        * 条件を満たすか否かによって適用するdecorateを分岐するためのdecorator
    * 遅延デコレータ
        * 最初に使用される時までインスタンス化されないインタフェースへの参照をクライアントに提供するためのデコレータ
    * ロギングデコレータ
        * コードのあちこちでログを吐き出すためのデコレータ
    * プロファイリングデコレータ
    * 非同期デコレータ
        * メインスレッドの処理を止めないよう別スレッドで動くデコレータ
        * 非同期メソッドがアプローチとして適しているのは、呼び出したら後は忘れてしまえるような一方向スタイルのメソッドだけ
        * リクエスト/レスポンススタイルのメソッドについては非同期デコレータを使って実装するのは不可能
    * プロパティとイベントのデコレート
        * プロパティ: getter/setterアクセサ内にdecorateの処理を書けばよい
        * イベント: Eventのadd/removeアクセサ内にdecorateの処理を書けばよい


# switchの代わりにStrategyパターンを使え