# 開放/閉鎖の原則

* Meyerの定義
    * ソフトウェアエンティティは拡張に対して開いていなければならず、変更に対して閉じていなければいけない
* Martinの定義
    * 拡張に対して開いている: モジュールのふるまいを拡張できることを意味する。アプリケーションの要求が変化したら、それらの変更内容を満たす新しいふるまいでモジュールを拡張することが可能である。言い換えれば、モジュールが実行することを変更できるのである
    * 変更に対して閉じている: モジュールのふるまいを拡張した結果として、モジュールのソースやバイナリコードで変更が発生しない。モジュールのバイナリコードは、リンク可能なライブラリなのか、DLLなのか、Javaの.jarなのかにかかわらず、変更されないものとなる

 # バグの修正
* 修正のプロセス
    1. バグをターゲット措定失敗するユニットテストと統合テストを作成する
    2. ユニットテストが成功するようにソースコードを修正する
    
# クライアントによる認識
* 「変更に対して閉じている」ルールに対する更に寛大な例外は、そのコードのクライアント側を変更する必要がない限り、既存のコードに対する変更をすべて認める、というもの
* これを実現するには、疎結合なシステムにする必要がある

# 拡張ポイント
* 拡張ポイント: 将来新しい機能が追加された時に、既存のコードにフックして、新しいふるまいを提供するようにするための仕掛け
* OCPに従っているクラスは、拡張ポイントを定義することにより、拡張に対して開いていなければいけない

## 拡張ポイントがない場合
* TradeProcessorクラスの変更が必要になったとき、TradeProcessorVersion2という新しいクラスを作成し、新機能はそこに追加する
    * クライアントがTradeProcessorクラスに直接依存していてTradeProcessorクラスに拡張ポイントがないため
    * TradeProcessorに依存しているTradeProcessorClientを編集しなければいけない
    * ProcessTradesメソッドを変更するなら、単なるクラスの実装上の変更ではなく、インタフェースの変更になる。クライアントは常にサービスのインタフェースに蜜結合されるため、インタフェースの変更は全てクライアントの変更を意味する

## 仮想メソッド
* メンバーの1つがvirtualとして宣言されているクラスは、拡張に対して開いている
* TradeProcessorクラスで新しい機能が要求された場合、既存のTradeProcessorクラスのサブクラスを作って、virtualメソッドをオーバーライドすることで挙動が変更できる
    * これならTradeProcessorClientを変更する必要がある
    * オーバーライドした仮想メソッドで基底の内容を呼び出した後に拡張分の処理を書くか、完全に再実装するかのどちらかをやる必要がある
        * 元のメソッドを変更するのは不可能

## 抽象メソッド
* Template Methodパターン
* 抽象クラスTradeProcessorAbstractを継承したクラスをアップデートの度に追加していく

## インタフェースの継承
* (!!!)クライアントはインタフェースに依存させよ(!!!)
* これが望ましい
    * 様々なコンテキストをカバーする機能のオブジェクトグラフを使ってデコレートすることが可能だから

## 継承を意図して設計するか、継承を禁止する
* 継承を意図して設計、文書からする。そうでなければ、継承を禁止する。
* 継承させるのを防ぎたい場合は、sealedキーワードを用いて明確な意思表示をせよ

# 保護されたバリエーション
* OCPをいつどこで適用するのか
    * 保護されたバリエーション
        * 予想されるバリエーションのポイントを特定し、それらのまわりに安定したインタフェースを作成する
        * 予想されるバリエーションのほうが正確な用語（と筆者は言ってる）
        * 予想されるバリエーション
            * 将来発生しうる拡張をプロダクトオーナーとのヒアリングを通じて把握しておく
            * それに絡むオブジェクトやその周辺は拡張ポイントを仕込んでおく
    * 安定したインタフェース
        * Stairwayパターン: インタフェースとその実装は別々のアセンブリに配置する
        * インタフェースが変化する可能性と頻度が低くなるように設計する必要がある
    * 程よい適応力
        * ゴルディロックスゾーン
            * 適度な量の拡張ポイントが含まれているコード
            * 適度な量: ソリューションを複雑にしたり性能過剰にしたりせずに必要な部分での変更が可能になる量
        * TradeProcessorは最初神オブジェクトだったらしい。
        * 変更される可能性が非常に低いという結論に達した場合は、コードはもとのままで十分というのもある
            * あまりインタフェースを定義しすぎると、かえって読みにくくなる
            * 拡張ポイントを意識して開発するのも時間かかるし...
        * いい塩梅で抽象化の粒度を判断できるようになろう
            * 経験を積むしかない